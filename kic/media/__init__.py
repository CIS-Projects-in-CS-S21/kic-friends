# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: proto/media.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import AsyncIterable, AsyncIterator, Dict, Iterable, List, Optional, Union

import betterproto
from betterproto.grpc.grpclib_server import ServiceBase
import grpclib


class DownloadFileByNameError(betterproto.Enum):
    """
    These are errors used to inform the client that is requesting a connection
    (downloading a file) what the issue is.The variable names denote the issue.
    """

    # FILE_NOT_FOUND denotes if file is not found.
    FILE_NOT_FOUND = 0
    # BUCKET_NOT_FOUND denotes if bucket is not found.
    BUCKET_NOT_FOUND = 1


class MetadataStrictness(betterproto.Enum):
    """
    Flags sent with a get file by metadata request to tell the server how
    seriously it wants the metadata request to be conformed to
    """

    # Only include a given file if all key value pairs match
    STRICT = 0
    # Include a file if it matches any of the key value pairs
    CASUAL = 1
    # Only include a file if it fails to match all key value pairs
    STRICTLY_OPPOSITE = 2
    # Only include a file if it matches less than all key value pairs
    CASUALLY_OPPOSITE = 3


@dataclass(eq=False, repr=False)
class UploadFileRequest(betterproto.Message):
    """Request to upload file for user."""

    file_info: "_common__.File" = betterproto.message_field(1, group="data")
    chunk: bytes = betterproto.bytes_field(2, group="data")

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UploadFileResponse(betterproto.Message):
    """Response to user requesting file upload."""

    # Id of file being uploaded
    file_id: str = betterproto.string_field(1)
    # Size of file in bytes
    bytes_read: int = betterproto.uint64_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class CheckForFileRequest(betterproto.Message):
    """Request to check for file for user."""

    # Information of file to be checked
    file_info: "_common__.File" = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class CheckForFileResponse(betterproto.Message):
    """Response to check for file for user."""

    # Returns true if file is found to exist
    exists: bool = betterproto.bool_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class DownloadFileRequest(betterproto.Message):
    """Request to download file for user"""

    # Information of file to be downloaded
    file_info: "_common__.File" = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class DownloadFileResponse(betterproto.Message):
    """Response to download file for user"""

    error: "DownloadFileByNameError" = betterproto.enum_field(1, group="data")
    chunk: bytes = betterproto.bytes_field(2, group="data")

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class GetFilesByMetadataRequest(betterproto.Message):
    """Request to get files for user by metadata request"""

    # Map of desired metadata
    desired_metadata: Dict[str, str] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    # Flags sent with a get file by metadata request to tell the server how
    # seriously it wants the metadata request to be conformed to
    strictness: "MetadataStrictness" = betterproto.enum_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class GetFilesByMetadataResponse(betterproto.Message):
    """Response to get files for user by metadata request"""

    # Information of file to be downloaded
    file_infos: List["_common__.File"] = betterproto.message_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class DeleteFilesWithMetaDataRequest(betterproto.Message):
    """Request to delete file for user with metadata request"""

    # Map of desired metadata of file to be deleted
    metadata: Dict[str, str] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    # Flags sent to tell the server how seriously it wants the metadata request
    # to be conformed to
    strictness: "MetadataStrictness" = betterproto.enum_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class DeleteFilesWithMetaDataResponse(betterproto.Message):
    """Response to  delete file for user with metadata request"""

    success: bool = betterproto.bool_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UpdateFilesWithMetadataRequest(betterproto.Message):
    # Map of desired metadata of file to be deleted
    metadata: Dict[str, str] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )
    # Flags sent to tell the server how seriously it wants the metadata request
    # to be conformed to
    strictness: "MetadataStrictness" = betterproto.enum_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class UpdateFilesWithMetadataResponse(betterproto.Message):
    num_files_update: int = betterproto.int64_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class AddCommentToFileRequest(betterproto.Message):
    commenter_username: str = betterproto.string_field(1)
    comment: str = betterproto.string_field(2)

    def __post_init__(self) -> None:
        super().__post_init__()


@dataclass(eq=False, repr=False)
class AddCommentToFileResponse(betterproto.Message):
    success: bool = betterproto.bool_field(1)

    def __post_init__(self) -> None:
        super().__post_init__()


class MediaStorageStub(betterproto.ServiceStub):
    """Service handling fetching and storing data about files."""

    async def upload_file(
        self,
        request_iterator: Union[
            AsyncIterable["UploadFileRequest"], Iterable["UploadFileRequest"]
        ],
    ) -> "UploadFileResponse":
        """
        Send a file as a stream of messages, starting with a message containing
        a File message, then followed by an arbitrary number of messages
        containing bytes representing the file. The response will then confirm
        the number of bytes received or provide an error.
        """

        return await self._stream_unary(
            "/kic.media.MediaStorage/UploadFile",
            request_iterator,
            UploadFileRequest,
            UploadFileResponse,
        )

    async def download_file_by_name(
        self, *, file_info: "_common__.File" = None
    ) -> AsyncIterator["DownloadFileResponse"]:
        """
        Using the same format as above, the service allows the client to
        retrieve a stored file.
        """

        request = DownloadFileRequest()
        if file_info is not None:
            request.file_info = file_info

        async for response in self._unary_stream(
            "/kic.media.MediaStorage/DownloadFileByName",
            request,
            DownloadFileResponse,
        ):
            yield response

    async def check_for_file_by_name(
        self, *, file_info: "_common__.File" = None
    ) -> "CheckForFileResponse":
        """Check for the existence of a file by filename"""

        request = CheckForFileRequest()
        if file_info is not None:
            request.file_info = file_info

        return await self._unary_unary(
            "/kic.media.MediaStorage/CheckForFileByName", request, CheckForFileResponse
        )

    async def update_files_with_metadata(
        self,
        *,
        metadata: Dict[str, str] = None,
        strictness: "MetadataStrictness" = None,
    ) -> "UpdateFilesWithMetadataResponse":

        request = UpdateFilesWithMetadataRequest()
        request.metadata = metadata
        request.strictness = strictness

        return await self._unary_unary(
            "/kic.media.MediaStorage/UpdateFilesWithMetadata",
            request,
            UpdateFilesWithMetadataResponse,
        )

    async def add_comment_to_file(
        self, *, commenter_username: str = "", comment: str = ""
    ) -> "AddCommentToFileResponse":

        request = AddCommentToFileRequest()
        request.commenter_username = commenter_username
        request.comment = comment

        return await self._unary_unary(
            "/kic.media.MediaStorage/AddCommentToFile",
            request,
            AddCommentToFileResponse,
        )

    async def get_files_with_metadata(
        self,
        *,
        desired_metadata: Dict[str, str] = None,
        strictness: "MetadataStrictness" = None,
    ) -> "GetFilesByMetadataResponse":
        """
        Allows for the requesting of files with specific key value pairs as
        metadata. The strictness can be set such that for example only perfect
        matches will be returned.
        """

        request = GetFilesByMetadataRequest()
        request.desired_metadata = desired_metadata
        request.strictness = strictness

        return await self._unary_unary(
            "/kic.media.MediaStorage/GetFilesWithMetadata",
            request,
            GetFilesByMetadataResponse,
        )

    async def delete_files_with_meta_data(
        self,
        *,
        metadata: Dict[str, str] = None,
        strictness: "MetadataStrictness" = None,
    ) -> "DeleteFilesWithMetaDataResponse":
        """
        Using the same strictness settings as the above, delete particular
        files with certain metadata.
        """

        request = DeleteFilesWithMetaDataRequest()
        request.metadata = metadata
        request.strictness = strictness

        return await self._unary_unary(
            "/kic.media.MediaStorage/DeleteFilesWithMetaData",
            request,
            DeleteFilesWithMetaDataResponse,
        )


class MediaStorageBase(ServiceBase):
    """Service handling fetching and storing data about files."""

    async def upload_file(
        self, request_iterator: AsyncIterator["UploadFileRequest"]
    ) -> "UploadFileResponse":
        """
        Send a file as a stream of messages, starting with a message containing
        a File message, then followed by an arbitrary number of messages
        containing bytes representing the file. The response will then confirm
        the number of bytes received or provide an error.
        """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def download_file_by_name(
        self, file_info: "_common__.File"
    ) -> AsyncIterator["DownloadFileResponse"]:
        """
        Using the same format as above, the service allows the client to
        retrieve a stored file.
        """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def check_for_file_by_name(
        self, file_info: "_common__.File"
    ) -> "CheckForFileResponse":
        """Check for the existence of a file by filename"""

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def update_files_with_metadata(
        self, metadata: Dict[str, str], strictness: "MetadataStrictness"
    ) -> "UpdateFilesWithMetadataResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def add_comment_to_file(
        self, commenter_username: str, comment: str
    ) -> "AddCommentToFileResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def get_files_with_metadata(
        self, desired_metadata: Dict[str, str], strictness: "MetadataStrictness"
    ) -> "GetFilesByMetadataResponse":
        """
        Allows for the requesting of files with specific key value pairs as
        metadata. The strictness can be set such that for example only perfect
        matches will be returned.
        """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def delete_files_with_meta_data(
        self, metadata: Dict[str, str], strictness: "MetadataStrictness"
    ) -> "DeleteFilesWithMetaDataResponse":
        """
        Using the same strictness settings as the above, delete particular
        files with certain metadata.
        """

        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_upload_file(self, stream: grpclib.server.Stream) -> None:
        request_kwargs = {"request_iterator": stream.__aiter__()}

        response = await self.upload_file(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_download_file_by_name(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "file_info": request.file_info,
        }

        await self._call_rpc_handler_server_stream(
            self.download_file_by_name,
            stream,
            request_kwargs,
        )

    async def __rpc_check_for_file_by_name(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "file_info": request.file_info,
        }

        response = await self.check_for_file_by_name(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_update_files_with_metadata(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "metadata": request.metadata,
            "strictness": request.strictness,
        }

        response = await self.update_files_with_metadata(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_add_comment_to_file(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "commenter_username": request.commenter_username,
            "comment": request.comment,
        }

        response = await self.add_comment_to_file(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_get_files_with_metadata(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "desired_metadata": request.desired_metadata,
            "strictness": request.strictness,
        }

        response = await self.get_files_with_metadata(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_delete_files_with_meta_data(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "metadata": request.metadata,
            "strictness": request.strictness,
        }

        response = await self.delete_files_with_meta_data(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/kic.media.MediaStorage/UploadFile": grpclib.const.Handler(
                self.__rpc_upload_file,
                grpclib.const.Cardinality.STREAM_UNARY,
                UploadFileRequest,
                UploadFileResponse,
            ),
            "/kic.media.MediaStorage/DownloadFileByName": grpclib.const.Handler(
                self.__rpc_download_file_by_name,
                grpclib.const.Cardinality.UNARY_STREAM,
                DownloadFileRequest,
                DownloadFileResponse,
            ),
            "/kic.media.MediaStorage/CheckForFileByName": grpclib.const.Handler(
                self.__rpc_check_for_file_by_name,
                grpclib.const.Cardinality.UNARY_UNARY,
                CheckForFileRequest,
                CheckForFileResponse,
            ),
            "/kic.media.MediaStorage/UpdateFilesWithMetadata": grpclib.const.Handler(
                self.__rpc_update_files_with_metadata,
                grpclib.const.Cardinality.UNARY_UNARY,
                UpdateFilesWithMetadataRequest,
                UpdateFilesWithMetadataResponse,
            ),
            "/kic.media.MediaStorage/AddCommentToFile": grpclib.const.Handler(
                self.__rpc_add_comment_to_file,
                grpclib.const.Cardinality.UNARY_UNARY,
                AddCommentToFileRequest,
                AddCommentToFileResponse,
            ),
            "/kic.media.MediaStorage/GetFilesWithMetadata": grpclib.const.Handler(
                self.__rpc_get_files_with_metadata,
                grpclib.const.Cardinality.UNARY_UNARY,
                GetFilesByMetadataRequest,
                GetFilesByMetadataResponse,
            ),
            "/kic.media.MediaStorage/DeleteFilesWithMetaData": grpclib.const.Handler(
                self.__rpc_delete_files_with_meta_data,
                grpclib.const.Cardinality.UNARY_UNARY,
                DeleteFilesWithMetaDataRequest,
                DeleteFilesWithMetaDataResponse,
            ),
        }


from .. import common as _common__
