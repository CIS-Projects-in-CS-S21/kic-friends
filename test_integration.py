import asyncio
import unittest
import os

from grpclib import GRPCError
from grpclib.client import Channel

# generated by protoc
from proto.common_pb2 import User
from proto.friends_pb2 import *
from proto.friends_grpc import FriendsStub


async def asyncSetUp(tests):
    location = 'localhost'
    if os.getenv("URL"):
        location = os.getenv("URL")
    channel = Channel(location, 50051)
    greeter = FriendsStub(channel)
    tests.client = greeter
    repo = {
        1: [5, 6, 8],
        5: [1, 2, 3, 6, 8, 20, 25],
        8: [1, 3, 5],
        10: [20, 40],
        20: [5, 10],
        25: [5, 10],
        30: [35],
        35: [30],
    }
    for uid in repo:
        for f_uid in repo[uid]:
            await tests.client.CreateConnectionForUsers(
                CreateConnectionForUsersRequest(
                    firstUserID=uid,
                    secondUserID=f_uid,
                )
            )
    await tests.client.AddAwaitingFriend(
        AddAwaitingFriendRequest(
            firstUserID=65,
            secondUserID=70,
        )
    )


class IntegrationTests(unittest.IsolatedAsyncioTestCase):
    client = None

    # Check that if we attempt to get an existing user's friends we get the proper list
    async def test_get_existing_friends_list(self):
        resp = await self.client.GetFriendsForUser(GetFriendsForUserRequest(
            user=User(
                userID=5,
                userName="test",
                email="test",
            )
        ))
        friends = list(resp.friends)
        # includes friends who add
        self.assertListEqual(friends, [1, 2, 3, 6, 8, 20, 25])

    # Check that if we attempt to get a not existing user's friends we get an empty proper list
    async def test_get_nonexisting_friends_list(self):
        resp = await self.client.GetFriendsForUser(GetFriendsForUserRequest(
            user=User(
                userID=1000,
                userName="test",
                email="test",
            )
        ))
        friends = list(resp.friends)
        self.assertListEqual(friends, [])

    # Check that if we delete an existing friend and user combo that we succeed
    async def test_delete_friend_existing(self):
        await self.client.DeleteConnectionBetweenUsers(
            DeleteConnectionBetweenUsersRequest(
                firstUserID=8,
                secondUserID=1,
            )
        )
        res1 = await self.client.GetFriendsForUser(
            GetFriendsForUserRequest(
                user=User(
                    userID=8,
                )
            )
        )
        u1_friends_list = sorted(list(res1.friends))

        res2 = await self.client.GetFriendsForUser(
            GetFriendsForUserRequest(
                user=User(
                    userID=1,
                )
            )
        )
        u2_friends_list = sorted(list(res2.friends))

        self.assertListEqual(u1_friends_list, [3, 5])
        self.assertListEqual(u2_friends_list, [5, 6])

    async def test_delete_friend_not_existing(self):
        with self.assertRaises(GRPCError) as context:
            await self.client.DeleteConnectionBetweenUsers(
                DeleteConnectionBetweenUsersRequest(
                    firstUserID=1000,
                    secondUserID=1,
                )
            )

        self.assertTrue(context.exception is not None)

    async def test_add_friend_existing(self):
        success = await self.client.CreateConnectionForUsers(
            CreateConnectionForUsersRequest(
                firstUserID=20,
                secondUserID=25,
            )
        )
        self.assertTrue(success.success)
        res1 = await self.client.GetFriendsForUser(
            GetFriendsForUserRequest(
                user=User(
                    userID=20,
                )
            )
        )
        u1_friends_list = sorted(list(res1.friends))
        res2 = await self.client.GetFriendsForUser(
            GetFriendsForUserRequest(
                user=User(
                    userID=25,
                )
            )
        )
        u2_friends_list = sorted(list(res2.friends))
        self.assertListEqual(u1_friends_list, [5, 10, 25])
        self.assertListEqual(u2_friends_list, [5, 10, 20])

    async def test_add_friend_already_existing(self):
        success = await self.client.CreateConnectionForUsers(
            CreateConnectionForUsersRequest(
                firstUserID=30,
                secondUserID=35,
            )
        )
        self.assertFalse(success.success)

    async def test_get_awaiting_friend(self):
        res = await self.client.GetAwaitingFriendsForUser(GetFriendsForUserRequest(
                user=User(
                    userID=65,
                )
            )
        )
        self.assertListEqual(list(res.friends), [70])

    async def test_add_awaiting_friend(self):
        success = await self.client.AddAwaitingFriend(
            AddAwaitingFriendRequest(
                firstUserID=90,
                secondUserID=95,
            )
        )
        self.assertTrue(success.success)
        res1 = await self.client.GetAwaitingFriendsForUser(
            GetFriendsForUserRequest(
                user=User(
                    userID=90,
                )
            )
        )
        u1_friends_list = list(res1.friends)
        res2 = await self.client.GetAwaitingFriendsForUser(
            GetFriendsForUserRequest(
                user=User(
                    userID=95,
                )
            )
        )
        u2_friends_list = list(res2.friends)
        self.assertListEqual(u1_friends_list, [95])
        self.assertListEqual(u2_friends_list, [90])


async def main():
    t = IntegrationTests()
    await asyncSetUp(t)
    await t.test_get_existing_friends_list()
    await t.test_get_nonexisting_friends_list()
    await t.test_delete_friend_existing()
    await t.test_delete_friend_not_existing()
    await t.test_add_friend_existing()
    await t.test_add_friend_already_existing()
    await t.test_add_awaiting_friend()
    await t.test_get_awaiting_friend()


if __name__ == '__main__':
    asyncio.run(main())
